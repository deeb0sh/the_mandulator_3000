import jwt from '@fastify/jwt'
import { headersJwtValid } from '../schemas/headersJWTvalid.js'
import { paramReqValid } from '../schemas/paramReqValid.js'
import { statLoginValid } from '../schemas/statLoginValid.js'
import cron from 'node-cron'
import NodeCache from 'node-cache'
export default async function wgstatsApi(fastify) {
  
  // === —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º (–û–ü–Ø–¢–¨) –ø–ª–∞–≥–∏–Ω
  fastify.register(jwt, {
    secret: process.env.JWT_SECRET
  })

  const cache = new NodeCache({ 
    stdTTL: 180,
    checkperiod: 60 
  }) // —Å–æ–∑–¥–∞—ë–º –∫–µ—à –¥–ª—è —Ö—Ä–∞–Ω–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –≤—Å–µ–≥–¥–∞ ( —Ö—Ä–∞–Ω–∏–º—Ç—Å—è –ø–æ–∫–∞ –Ω–µ –ø–µ—Ä–µ–∑–∞–ø–∏—à–µ—Ç—Å—è)

  const servers = {
    RU: 'http://wgru:3003/wgstats',
    DE: 'http://wgde:3003/wgstats',
    FI: 'http://wgfi:3003/wgstats'
  }

  const antiFlood = new Set(); // –≥–ª–æ–±–∞–ª—å–Ω–∞—è –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è —Ñ–ª—É–¥–∞
  const flag = {
              "RU": "üá∑üá∫",
              "DE": "üá©üá™",
              "FI": "üá´üáÆ" 
            };

  // === —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–ø—Ä–æ—Å–∞ —Å–µ—Ä–≤–µ—Ä–æ–≤ –∏ –∑–∞–ø–∏–ª –æ—Ç–≤–µ—Ç–∞ –≤ –∫–µ—à
  async function wgStats(server) {
      // try-catch –¥–ª—è fetch
      try {
        const response = await fetch(servers[server],{
          signal: AbortSignal.timeout(3000) // 3 —Å–µ–∫ –∂–¥—ë–º –æ—Ç–≤–µ—Ç –µ—Å–ª–∏ –±–æ–ª—å—à–µ —Ç–æ AbortError –∏–ª–∏ TimeoutError
        })  // 3000 –º—Å
        const stats = await response.json()
        // --- –∑–∞–ø–∏—Å—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∫–µ—à –∏ —Å—Ç–∞—Ç—É—Å —Å–µ—Ä–≤–µ—Ä–∞
        cache.set(server, {
          status: 'online',
          data: stats,       // –û—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
          lastUpdated: new Date().toLocaleString()
        })
        // –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ —Ç–µ–ª–µ–≥—É –µ—Å–ª–∏ —Å–µ—Ä–≤–µ—Ä –æ–Ω–ª–∞–π–Ω
        if (antiFlood.has(server)) {
          antiFlood.delete(server)
          // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ —Ç–ª–µ–≥—É
          try {
            await fetch('http://bot:3333/bot/msg', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    message: `‚úÖ C–µ—Ä–≤–µ—Ä ${flag[server]} –ø–æ–¥–Ω—è–ª—Å—è !`
                })
            });
          } 
          catch (err) {
            console.error(`[WGSTATS] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ Telegram: ${err}`);
          }
        }

      } 
      catch (e) {
        cache.set(server, {
          status: 'offline',
          lastUpdated: new Date().toLocaleString()
        })
        
        console.log(`[${new Date().toLocaleString()}][WGSTATS] –°–µ—Ä–≤–µ—Ä –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç - ${server}: ${e}`)
        
        if (!antiFlood.has(server)) {
          // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ —Ç–ª–µ–≥—É
          try {
            await fetch('http://bot:3333/bot/msg', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    message: `‚ùå –°–µ—Ä–≤–µ—Ä ${flag[server]} —É–ø–∞–ª !`
                })
            });
            antiFlood.add(server)
          } 
          catch (err) {
            console.error(`[WGSTATS] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ Telegram: ${err}`);
          }
          
        }
      }
    }
  
  // === –æ–ø—Ä–∞—à–∏–≤–∞–µ–º —Å–µ—Ä–≤–µ—Ä—ã –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥
  cron.schedule('*/5 * * * * *', async () => {
    await Promise.all(Object.keys(servers).map(wgStats));
  })
  
  // === –µ–Ω–¥-–ø–æ–∏–Ω—Ç—ã –¥–ª—è —Ñ—Ä–æ–Ω—Ç-–µ–Ω–¥–∞ + –≤–∞–ª–∏–¥–∞—Ü–∏—è —Ö–µ–¥–µ—Ä–∞ (–∫–∞–∂–¥–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Å–≤–æ–∏ –ø–∏—Ä—ã)
  fastify.get('/wg/stats/:server', { 
    schema:{ 
      headers: headersJwtValid, // –≤–∞–ª–∏–¥–∞—Ü–∏—è —Ö–µ–¥–µ—Ä–∞
      params: paramReqValid // –≤–∞–ª–∏–¥–∞—Ü–∏—è :server
    }}, async (request, reply) => {
      try {
        const decod = await request.jwtVerify()
        const user = decod.user
        const { server } = request.params
        // --- –∏–∑–≤–ª–µ–∫–∞–µ–º –∏–∑ –∫–µ—à–∞
        const stats = cache.get(server) 
        if (stats.status === 'offline') {
          return reply.send(stats)
        }
        // --- –ø–æ–ª—É—á–∞–µ–º –≤—Å–µ –ø—É–±–ª–∏—á–Ω—ã–µ –∫–ª—é—á–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –±–∞–∑—ã 
        const userPeers = await fastify.prisma.client.findMany({
          where: {
            user: {
              login: user
            },
            serverName: server
          },
          select: {
            id: true,
            publicKey: true
          }
        })
        const publicKeyToId = Object.fromEntries(
          userPeers.map(({ id, publicKey }) => [publicKey, id]) // –¥–ª—è –ø–æ—Å–∫–∞–µ id –ø–æ publicKey
        )
        //const userPublicKeys = userPeers.map(pkey => pkey.publicKey) // –æ—Å—Ç–∞–≤–ª—è–µ–º –≤ –º–∞—Å—Å–∏–≤–µ userPeers —Ç–æ–ª—å–∫–æ –∑–Ω–∞—á–µ–Ω–∏—è publicKey       
        
        const userStats = stats.data.peers
          .filter(peer => publicKeyToId.hasOwnProperty(peer.publicKey)) // –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Å–≤–æ–∏ peers
          .map(({ publicKey, ...rest }) => ({
            ...rest,
            id: publicKeyToId[publicKey] // –∑–∞–º–µ–Ω—è–µ–º publicKey –Ω–∞ id
        }))

        // const userStats = stats.data.peers.filter(peer => userPublicKeys.includes(peer.publicKey)) // –≤—ã–ø–∏–ª–∏–≤–∞–µ–º –∏–∑ –º–∞—Å—Å–∏–≤–∞ stats.data.peers –≤—Å—ë –ª–∏—à–Ω–µ–µ –∫–∞—Ä–æ—á–µ
        // //stats.data.peers = userPeers
        const normalStats = {
          status: stats.status,
          lastUpdated: stats.lastUpdated,
          data: {
            peers: userStats
          }
        }
        //console.log(JSON.stringify(stats, null, 2))
        return reply.send(normalStats)
      } 
      catch(e) {
        return reply.send({ message: "invalid", onErr: e})    
      }
  })

  // === –ï–Ω–¥-–ø–æ–∏–Ω—Ç –¥–ª—è —Ä–æ–ª–∏ 3 (–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞) —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –ø–∏—Ä–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
  // –¥–ª—è –≤—ã—è–≤–ª–µ–Ω–∏—è –Ω–µ–∏—Å–ø–æ–ª—å—Ö—É–µ–º—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤
  fastify.get('/wg/stats/user/:login',{
    schema: {
      headers: headersJwtValid,
      params: statLoginValid
    }},
    async (request,reply) => {
      try {
        const decod = await request.jwtVerify()
        const roleID = decod.role
        if (roleID != 3) {
          return reply.send({ message: "invalid", error: "–Ω–µ—Ç –ø—Ä–∞–≤" })
        }
        const { login } = request.params
        // --- –≤—Å–µ –ø–∏—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        const userClients = await fastify.prisma.client.findMany({
          where: {
            user: {
              login: login
            }
          },
          select: {
            name: true,       // –∏–º—è –ø–∏—Ä–∞
            ip: true,         // IP –∞–¥—Ä–µ—Å
            publicKey: true,
            serverName: true  // —Å–µ—Ä–≤–µ—Ä (RU/DE/FI)
        }})
        // --- –≤—Å–µ–º —Å—Ç–∞—Ç–∏—Ç–∏–∫—É –∏–∑ –∫–µ—à–∞ –≤ —Å–æ–æ—Å—Ç–≤–µ—Ç—Å–≤–∏–∏ —Å publicKey –∏ –∫–ª—é—á–µ –∫–µ—à–∞ serverName
        const userStats = []
        for (const client of userClients) {  
          const serverStats = cache.get(client.serverName) 
          const peerStats = serverStats.data.peers.find(peer => peer.publicKey === client.publicKey)
          // –ï—Å–ª–∏ –ø–∏—Ä –Ω–∞–π–¥–µ–Ω –≤ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–µ
          if (peerStats) {
            userStats.push({
              name: client.name,
              ip: client.ip,
              server: client.serverName,
              lastHandshake: peerStats.lastHandshake,
              transferRx: peerStats.rx,
              transferTx: peerStats.tx,
            })
          } 
          else {
            // –ï—Å–ª–∏ –ø–∏—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω (–Ω–æ —Å–µ—Ä–≤–µ—Ä –æ–Ω–ª–∞–π–Ω)
            userStats.push({
              name: client.name,
              ip: client.ip,
              server: client.serverName,
              lastHandshake: 'N/A',
              transferRx: 'N/A',
              transferTx: 'N/A',
            })
          }
          return reply.send({
            user: login,
            peers: userStats
          }) 
        }
      }
      catch (e) {
        
      }
    }
  )

}